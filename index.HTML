<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Webverse: Perfect Deck Builder</title>
    <style>
        /* --- ê³µí†µ ë³€ìˆ˜ --- */
        :root {
            --bg-dark: #121212;
            --bg-panel: #1e1e24;
            --accent: #f1c40f;
            --text-main: #ecf0f1;
            --border: #333;
            --card-width: 110px;
            --card-height: 150px;
        }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%); 
            color: var(--text-main); 
            margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; user-select: none; 
        }

        /* --- 1. ë± ë¹Œë” ë ˆì´ì•„ì›ƒ (ìˆ˜ì •ë¨) --- */
        #deck-builder-screen { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: var(--bg-dark); z-index: 10000; display: flex; flex-direction: column; 
        }

        /* í—¤ë” */
        .builder-header { 
            height: 60px; background: #202020; border-bottom: 2px solid var(--accent); 
            display: flex; align-items: center; justify-content: space-between; padding: 0 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5); z-index: 10;
        }
        .builder-header h2 { margin: 0; color: var(--accent); font-size: 24px; letter-spacing: 1px; }
        .deck-counter { font-size: 18px; font-weight: bold; color: #fff; background: #333; padding: 5px 15px; border-radius: 20px; }

        /* ë°”ë””: ì¢Œì¸¡(ì¹´ë“œí’€) / ìš°ì¸¡(ë±ë¦¬ìŠ¤íŠ¸) */
        .builder-body { 
            flex: 1; display: flex; overflow: hidden; position: relative; 
        }

        /* [ìˆ˜ì •] ì¹´ë“œ í’€ ì˜ì—­ (ìŠ¤í¬ë¡¤ ê°€ëŠ¥) */
        .card-pool-container {
            flex: 1; 
            padding: 30px; 
            overflow-y: auto; 
            background: #1a1a1a;
        }

        /* [ìˆ˜ì •] ê·¸ë¦¬ë“œ ì‹œìŠ¤í…œ (ë°˜ì‘í˜•) */
        .pool-grid { 
            display: grid; 
            /* í™”ë©´ ë„ˆë¹„ì— ë”°ë¼ ì¹´ë“œ ìë™ ë°°ì¹˜ (ìµœì†Œ ë„ˆë¹„ 120px) */
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); 
            gap: 20px; 
            width: 100%;
        }

        /* ìš°ì¸¡ ë± ë¦¬ìŠ¤íŠ¸ íŒ¨ë„ */
        .my-deck-panel { 
            width: 320px; 
            background: #151515; 
            border-left: 1px solid #444; 
            display: flex; flex-direction: column; 
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            z-index: 5;
        }
        .deck-list-scroll {
            flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 8px;
        }

        /* ë± ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œ (ë°” í˜•íƒœ) */
        .deck-item {
            display: flex; align-items: center; justify-content: space-between;
            background: linear-gradient(90deg, #2c3e50, #34495e);
            padding: 10px 15px; border-radius: 6px; cursor: pointer;
            border: 1px solid #444; transition: all 0.2s; position: relative; overflow: hidden;
        }
        .deck-item:hover { transform: translateX(-5px); border-color: var(--accent); }
        .deck-item::before { /* ì½”ìŠ¤íŠ¸ ë°°ê²½ë°” */
            content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 40px; 
            background: rgba(0,0,0,0.2); z-index: 0;
        }
        .item-cost { 
            width: 24px; height: 24px; background: #2980b9; color: white; border-radius: 50%; 
            display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 14px; 
            z-index: 1; border: 2px solid #8ecafc; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .item-name { flex: 1; margin-left: 15px; font-weight: bold; font-size: 14px; z-index: 1; text-shadow: 1px 1px 2px black; }
        .item-count { font-size: 14px; font-weight: bold; color: var(--accent); z-index: 1; }

        /* í‘¸í„° */
        .builder-footer { 
            height: 70px; background: #202020; border-top: 1px solid #333; 
            display: flex; align-items: center; justify-content: center; z-index: 10;
        }

        /* --- 2. ì¹´ë“œ ë””ìì¸ (UI ê°œì„ ) --- */
        .card { 
            width: var(--card-width); height: var(--card-height); 
            background: #f0f0f0; color: #333; 
            border-radius: 8px; position: relative; 
            display: flex; flex-direction: column; cursor: pointer; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.6); 
            border: 3px solid #777; 
            transition: transform 0.15s, box-shadow 0.15s;
            overflow: hidden;
        }
        .card:hover { transform: scale(1.1); z-index: 100; box-shadow: 0 10px 20px rgba(0,0,0,0.8); border-color: #fff; }
        
        .card-top { flex: 3; position: relative; background: #333; }
        .card-art { width: 100%; height: 100%; background-size: cover; background-position: center; }
        
        .card-bottom { flex: 2; background: #fff; padding: 2px; display: flex; flex-direction: column; justify-content: space-between; border-top: 2px solid #d4af37; }
        .card-name { font-size: 11px; font-weight: 800; text-align: center; background: #eee; padding: 2px 0; border-radius: 4px; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-desc { font-size: 9px; line-height: 1.2; text-align: center; color: #444; padding: 0 2px; height: 32px; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        
        .card-cost { 
            position: absolute; top: -4px; left: -4px; width: 28px; height: 28px; 
            background: radial-gradient(circle, #3498db, #2980b9); color: white; 
            border-radius: 50%; display: flex; justify-content: center; align-items: center; 
            font-weight: 900; font-size: 16px; border: 2px solid white; z-index: 5; box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
        }
        .enhance-active .card-cost { background: radial-gradient(circle, #2ecc71, #27ae60); transform: scale(1.1); }

        .stat-box { 
            position: absolute; bottom: 0; width: 34px; height: 30px; 
            display: flex; justify-content: center; align-items: center; 
            font-size: 16px; font-weight: 900; color: white; z-index: 5; text-shadow: 1px 1px 0 #000;
        }
        .stat-atk { left: 0; background: linear-gradient(45deg, #e67e22, #d35400); clip-path: polygon(0 0, 100% 0, 80% 100%, 0 100%); padding-right: 5px; border-top-right-radius: 10px; }
        .stat-hp { right: 0; background: linear-gradient(45deg, #c0392b, #e74c3c); clip-path: polygon(20% 0, 100% 0, 100% 100%, 0 100%); padding-left: 5px; border-top-left-radius: 10px; }

        .icon-row { position: absolute; top: 2px; right: 2px; display: flex; gap: 2px; z-index: 6; flex-wrap: wrap; justify-content: flex-end; width: 80px; pointer-events: none; }
        .keyword-icon { width: 18px; height: 18px; background: rgba(0,0,0,0.8); color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 11px; border: 1px solid white; box-shadow: 1px 1px 3px black; }

        /* ì¹´ë“œ ìƒíƒœ í…Œë‘ë¦¬ */
        .card.ward { border-color: #bdc3c7; box-shadow: 0 0 5px #bdc3c7; }
        .card.storm { border-color: #3498db; box-shadow: 0 0 5px #3498db; }
        .card.rush { border-color: #f39c12; box-shadow: 0 0 5px #f39c12; }
        .card.bane { border-bottom-color: #8e44ad; border-bottom-width: 5px; }
        .card.ambush { opacity: 0.8; filter: grayscale(0.5); }
        .card.evolved { border-color: #f1c40f; box-shadow: 0 0 20px #f1c40f !important; }
        .card.evolved .card-art { filter: sepia(0.4) contrast(1.2); }
        .card.playable { box-shadow: 0 0 15px #2ecc71; border-color: #2ecc71; }
        .card.can-attack { cursor: crosshair; box-shadow: 0 0 15px #e74c3c; border-color: #e74c3c; }
        .card.exhausted { filter: grayscale(1); cursor: default; }
        .card.enemy-card-back { background: linear-gradient(135deg, #2c3e50, #000); border: 2px solid #555; }

        /* --- 3. ê²Œì„ ë³´ë“œ ë ˆì´ì•„ì›ƒ --- */
        #game-board { flex: 1; display: flex; flex-direction: column; padding: 10px; max-width: 1400px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        .zone { display: flex; justify-content: center; align-items: center; position: relative; }
        .hand-zone { height: 160px; z-index: 100; gap: -30px; }
        .hero-zone { height: 110px; z-index: 50; }
        .field-zone { 
            flex: 1; margin: 5px 0; background: rgba(0,0,0,0.3); border-radius: 15px; 
            border: 2px solid #444; display: flex; justify-content: center; align-items: center; 
            gap: 15px; padding: 10px; transition: background 0.2s; 
        }
        .field-zone.drag-hover { background: rgba(46, 204, 113, 0.15); border-color: #2ecc71; box-shadow: 0 0 20px rgba(46, 204, 113, 0.2); }

        .hero { width: 100px; height: 100px; border-radius: 50%; border: 4px solid #555; display: flex; justify-content: center; align-items: center; font-weight: bold; background: #333; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.8); z-index: 10; }
        .hero.player { border-color: #3498db; } .hero.enemy { border-color: #c0392b; }
        .hero.valid-target { box-shadow: 0 0 30px #e74c3c; border-color: #e74c3c; cursor: crosshair; transform: scale(1.1); }
        .hp-badge { position: absolute; bottom: -12px; background: #222; padding: 4px 16px; border-radius: 15px; border: 2px solid #fff; font-size: 20px; font-weight: bold; color:white;}
        
        .ep-orbs { position: absolute; right: -40px; top: 15px; display: flex; flex-direction: column; gap: 6px; }
        .orb { width: 18px; height: 18px; background: #333; border-radius: 50%; border: 2px solid #666; box-shadow: inset 0 0 5px #000; }
        .orb.on { background: radial-gradient(circle at 30% 30%, #ffd700, #f39c12); border-color: #fff; box-shadow: 0 0 10px #f1c40f; }

        /* UI Controls */
        #controls { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; align-items: center; z-index: 2000; }
        .mana-display { font-size: 28px; font-weight: bold; color: var(--accent); text-shadow: 0 0 5px black; }
        .btn { width: 140px; padding: 12px; border-radius: 30px; border: none; font-weight: bold; cursor: pointer; color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.5); font-size: 16px; transition: transform 0.1s; }
        .btn:active { transform: translateY(2px); }
        .btn:disabled { background: #555 !important; cursor: not-allowed; opacity: 0.5; box-shadow: none; }
        #end-turn { background: linear-gradient(to bottom, #2ecc71, #27ae60); } 
        #evolve { background: linear-gradient(to bottom, #f1c40f, #f39c12); color: #222; }
        #evolve.active { border: 3px solid white; transform: scale(1.1); box-shadow: 0 0 20px #f1c40f; }
        #save-deck-btn { background: #27ae60; font-size: 20px; width: 200px; }

        #log-window { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); width: 220px; height: 250px; background: rgba(0,0,0,0.8); border: 1px solid #444; border-radius: 8px; overflow-y: auto; color: #ccc; font-size: 11px; padding: 10px; pointer-events: none; z-index: 100; }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 2px; }

        /* ì˜¤ë²„ë ˆì´ */
        #start-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 9000; display: none; flex-direction: column; justify-content: center; align-items: center; }
        .choice-btn { width: 220px; height: 140px; margin: 15px; border-radius: 15px; font-size: 22px; font-weight: bold; cursor: pointer; border: 3px solid #555; transition: transform 0.2s; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; }
        .choice-btn:hover { transform: scale(1.05); border-color: white; }

        .dragging { opacity: 0.4; }
        .valid-target { box-shadow: 0 0 30px #e74c3c !important; border-color: #e74c3c !important; transform: scale(1.05); z-index: 1000 !important; cursor: crosshair; }
        .selectable-target { border-color: #2ecc71 !important; box-shadow: 0 0 20px #2ecc71 !important; cursor: pointer !important; animation: pulse 1s infinite; z-index: 2000 !important; }
        @keyframes pulse { 0% { transform: scale(1.0); } 50% { transform: scale(1.05); } 100% { transform: scale(1.0); } }
    </style>
</head>
<body>

<div id="deck-builder-screen">
    <div class="builder-header">
        <h2>Deck Builder</h2>
        <div class="deck-counter" id="deck-count-display">0 / 40</div>
    </div>
    <div class="builder-body">
        <div class="card-pool-container">
            <div class="pool-grid" id="builder-pool"></div>
        </div>
        <div class="my-deck-panel">
            <div class="deck-list-scroll" id="builder-list"></div>
        </div>
    </div>
    <div class="builder-footer">
        <button class="btn" id="save-deck-btn" disabled onclick="toStartScreen()">ì™„ë£Œ</button>
    </div>
</div>

<div id="start-overlay">
    <h1 style="color:var(--accent); font-size: 40px; margin-bottom: 40px;">Game Start</h1>
    <div style="display:flex; gap:30px;">
        <button class="choice-btn" style="background:linear-gradient(135deg, #2980b9, #2c3e50);" onclick="startGame(true)">
            ì„ ê³µ (First)
            <span style="font-size:14px; opacity:0.8;">EP 2 / ì§„í™” 5í„´~</span>
        </button>
        <button class="choice-btn" style="background:linear-gradient(135deg, #c0392b, #2c3e50);" onclick="startGame(false)">
            í›„ê³µ (Second)
            <span style="font-size:14px; opacity:0.8;">EP 3 / ì§„í™” 4í„´~</span>
        </button>
    </div>
</div>

<div id="game-board">
    <div class="zone hand-zone" id="enemy-hand"></div>
    <div class="zone hero-zone">
        <div id="enemy-hero" class="hero enemy">
            Enemy <div class="hp-badge" id="e-hp">20</div>
            <div class="ep-orbs" id="e-ep"></div>
        </div>
    </div>
    <div class="field-zone" id="enemy-field"></div>
    <div class="field-zone" id="player-field"></div> 
    <div class="zone hero-zone">
        <div id="player-hero" class="hero player">
            You <div class="hp-badge" id="p-hp">20</div>
            <div class="ep-orbs" id="p-ep"></div>
        </div>
    </div>
    <div class="zone hand-zone" id="player-hand"></div>
</div>

<div id="controls">
    <div class="mana-display">ğŸ’ <span id="mana">0/0</span></div>
    <button id="evolve" class="btn" onclick="toggleEvolve()">âš¡ ì§„í™”</button>
    <button id="end-turn" class="btn" onclick="endTurn()">í„´ ì¢…ë£Œ</button>
</div>
<div id="log-window"></div>

<script>
    /* =========================================
       [1] ë°ì´í„°ë² ì´ìŠ¤ (ì˜¤ë¥˜ ë°©ì§€ìš© ê¸°ë³¸ê°’ ì²˜ë¦¬ í¬í•¨)
       ========================================= */
    const cardsDB = [
        { id: 1, cost: 1, atk: 1, hp: 2, name: "ê³ ë¸”ë¦°", desc: "ëŠ¥ë ¥ ì—†ìŒ", art: "https://via.placeholder.com/140x100/555/fff?text=Goblin" },
        { id: 2, cost: 1, atk: 1, hp: 1, name: "ì‹ ì†ì˜ ê²€ì‚¬", desc: "ì§ˆì£¼", passives: ['storm'], art: "https://via.placeholder.com/140x100/333/fff?text=QuickBlade" },
        { id: 3, cost: 2, atk: 2, hp: 2, name: "íŒŒì´í„°", desc: "ëŠ¥ë ¥ ì—†ìŒ", art: "https://via.placeholder.com/140x100/777/fff?text=Fighter" },
        { id: 4, cost: 2, atk: 1, hp: 3, name: "ë°©íŒ¨ë³‘", desc: "ìˆ˜í˜¸", passives: ['ward'], art: "https://via.placeholder.com/140x100/888/fff?text=Shield" },
        { id: 5, cost: 2, atk: 2, hp: 1, name: "ë‹Œì", desc: "ì ë³µ", passives: ['ambush'], art: "https://via.placeholder.com/140x100/222/fff?text=Ninja" },
        { id: 6, cost: 2, atk: 1, hp: 1, name: "ë…ì‚¬", desc: "í•„ì‚´", passives: ['bane'], art: "https://via.placeholder.com/140x100/609/fff?text=Snake" },
        { id: 7, cost: 2, atk: 2, hp: 2, name: "ê²¬ìŠµ ê¸°ì‚¬", desc: "ì¶œê²©: 1ì¥ ë“œë¡œìš°", fanfare: [{type:'draw', val:1}], art: "https://via.placeholder.com/140x100/349/fff?text=Draw" },
        { id: 8, cost: 2, atk: 2, hp: 2, name: "ìš©ì˜ ì „ë ¹", desc: "ì¶œê²©: ì¦ê°•(4) +2/+2", enhance: {cost:4, effects:[{type:'buff', atk:2, hp:2}]}, art: "https://via.placeholder.com/140x100/d60/fff?text=Enhance" },
        { id: 9, cost: 3, atk: 2, hp: 3, name: "ì¹˜ìœ ì‚¬", desc: "ì¶œê²©: ë¦¬ë” 2 íšŒë³µ", fanfare: [{type:'heal_leader', val:2}], art: "https://via.placeholder.com/140x100/fff/333?text=Heal" },
        { id: 10, cost: 3, atk: 3, hp: 2, name: "ì°½ìˆ ì‚¬", desc: "ê³µê²©ì‹œ: +1/+0", strike: [{type:'buff', atk:1, hp:0}], art: "https://via.placeholder.com/140x100/e67/fff?text=Strike" },
        { id: 11, cost: 3, atk: 2, hp: 2, name: "ë§ˆë²• ê¸°ì‚¬", desc: "ì§ˆì£¼", passives: ['storm'], art: "https://via.placeholder.com/140x100/39f/fff?text=Storm" },
        { id: 12, cost: 3, atk: 1, hp: 4, name: "ìœ ë ¹", desc: "ìœ„ì•• (ê³µê²©ë°›ì§€ ì•ŠìŒ)", passives: ['intimidate'], art: "https://via.placeholder.com/140x100/aaa/fff?text=Ghost" },
        { id: 13, cost: 3, atk: 1, hp: 1, name: "í•´ê³¨ ì†Œí™˜ì‚¬", desc: "ìœ ì–¸: í•´ê³¨(1/1) ì†Œí™˜", lastWords: [{type:'summon', id: 99}], art: "https://via.placeholder.com/140x100/333/fff?text=SkullSum" },
        { id: 14, cost: 4, atk: 3, hp: 4, name: "ì² ë²½ì˜ ê¸°ì‚¬", desc: "ìˆ˜í˜¸, ë°°ë¦¬ì–´", passives: ['ward', 'barrier'], art: "https://via.placeholder.com/140x100/ccc/333?text=Barrier" },
        { id: 15, cost: 4, atk: 4, hp: 3, name: "ë…¸ì¥êµ°", desc: "ì§„í™”ì‹œ: ë‚´ í•„ë“œ ì „ì²´ +1/+1", evolve: [{type:'buff_all', atk:1, hp:1}], art: "https://via.placeholder.com/140x100/c03/fff?text=General" },
        { id: 16, cost: 4, atk: 2, hp: 2, name: "ë¶ˆì‚¬ì¡°", desc: "ëŒì§„. ìœ ì–¸: íŒ¨ë¡œ ëŒì•„ì˜´", passives:['rush'], lastWords: [{type:'return_to_hand'}], art: "https://via.placeholder.com/140x100/f39/fff?text=Phoenix" },
        { id: 17, cost: 4, atk: 2, hp: 5, name: "í¡í˜ˆê·€", desc: "í•„ì‚´, í¡í˜ˆ", passives: ['bane', 'drain'], art: "https://via.placeholder.com/140x100/900/fff?text=Vampire" },
        { id: 18, cost: 5, atk: 4, hp: 5, name: "ê²€í˜¸", desc: "êµì „ì‹œ: ì  ì „ì²´ 1 í”¼í•´", clash: [{type:'aoe_damage', val:1}], art: "https://via.placeholder.com/140x100/555/fff?text=Samurai" },
        { id: 19, cost: 5, atk: 3, hp: 3, name: "ì²˜í˜•ì¸", desc: "ì¶œê²©: ì  ì¶”ì¢…ì í•˜ë‚˜ íŒŒê´´", fanfare: [{type:'destroy_enemy'}], art: "https://via.placeholder.com/140x100/000/fff?text=Killer" },
        { id: 20, cost: 6, atk: 5, hp: 6, name: "ìš©", desc: "ì˜¤ë¼ (ëŠ¥ë ¥ ëŒ€ìƒ ì•ˆë¨)", passives: ['aura'], art: "https://via.placeholder.com/140x100/060/fff?text=Dragon" },
        { id: 21, cost: 6, atk: 4, hp: 4, name: "í‘ë§ˆë²•ì‚¬", desc: "ì¶œê²©: ì¦ê°•(9) ì  ë¦¬ë” 5 í”¼í•´", enhance: {cost:9, effects:[{type:'damage_leader', val:5, target:'enemy'}]}, art: "https://via.placeholder.com/140x100/306/fff?text=Warlock" },
        { id: 22, cost: 7, atk: 5, hp: 5, name: "ëŒ€ì²œì‚¬", desc: "ìˆ˜í˜¸, í¡í˜ˆ, ì˜¤ë¼", passives: ['ward', 'drain', 'aura'], art: "https://via.placeholder.com/140x100/ffc/333?text=Archangel" },
        { id: 23, cost: 8, atk: 7, hp: 7, name: "ì œë„¤ì‹œìŠ¤", desc: "ì§ˆì£¼", passives: ['storm'], art: "https://via.placeholder.com/140x100/fff/000?text=Genesis" },
        { id: 24, cost: 10, atk: 10, hp: 10, name: "ë°”í•˜ë¬´íŠ¸", desc: "ì¶œê²©: ë‹¤ë¥¸ ëª¨ë“  ì¶”ì¢…ì íŒŒê´´", fanfare: [{type:'destroy_all_others'}], art: "https://via.placeholder.com/140x100/000/f00?text=Bahamut" },
        { id: 99, cost: 1, atk: 1, hp: 1, name: "í•´ê³¨", desc: "í† í°", art: "https://via.placeholder.com/140x100/eee/333?text=Skeleton" }
    ];

    /* ------------------------------------------------------------------
       2. ìƒíƒœ ë³€ìˆ˜
       ------------------------------------------------------------------ */
    let myDeckList = []; 
    let pDeck=[], eDeck=[], pHand=[], eHand=[], pField=[], eField=[];
    let myTurnCount=0, isPlayerTurn=false;
    let pMana=0, pMaxMana=0, eMana=0, eMaxMana=0;
    let pHP=20, eHP=20;
    let pEP=0, eEP=0;
    let isFirst = true;
    let evolvedThisTurn = false;
    let isEvolveMode = false;
    let draggedIdx = -1, dragSource = null;

    /* ------------------------------------------------------------------
       3. ë± ë¹Œë” ë¡œì§
       ------------------------------------------------------------------ */
    function initBuilder() {
        // [ìˆ˜ì •] ê¸°ë³¸ 30ì¥ ì±„ìš°ê¸° (ê° 3ì¥ì”© 10ì¢…ë¥˜)
        for(let i=0; i<10; i++) { addToDeck(cardsDB[i]); addToDeck(cardsDB[i]); addToDeck(cardsDB[i]); }
        renderBuilder();
    }

    function addToDeck(card) {
        let total = myDeckList.reduce((a,b)=>a+b.count,0);
        if(total>=40) return;
        let existing = myDeckList.find(x=>x.id===card.id);
        if(existing) { if(existing.count<3) existing.count++; }
        else myDeckList.push({id:card.id, count:1, data:card});
        renderBuilder();
    }

    function removeFromDeck(id) {
        let idx = myDeckList.findIndex(x=>x.id===id);
        if(idx>=0) {
            myDeckList[idx].count--;
            if(myDeckList[idx].count<=0) myDeckList.splice(idx,1);
            renderBuilder();
        }
    }

    function renderBuilder() {
        const pool = document.getElementById('builder-pool');
        const list = document.getElementById('builder-list');
        pool.innerHTML=''; list.innerHTML='';
        
        cardsDB.filter(c=>c.id!==99).forEach(c => {
            const div = document.createElement('div');
            div.className = 'card'; // ê³µí†µ ì¹´ë“œ ìŠ¤íƒ€ì¼
            div.innerHTML = renderCardInner(c, false);
            div.onclick = () => addToDeck(c);
            pool.appendChild(div);
        });

        let total = 0;
        myDeckList.sort((a,b)=>a.data.cost - b.data.cost).forEach(item => {
            total += item.count;
            const div = document.createElement('div');
            div.className = 'deck-item';
            div.innerHTML = `
                <div class="item-cost">${item.data.cost}</div>
                <div class="item-name">${item.data.name}</div>
                <div class="item-count">x${item.count}</div>
            `;
            div.onclick = () => removeFromDeck(item.id);
            list.appendChild(div);
        });

        document.getElementById('deck-count-display').innerText = `${total} / 40`;
        document.getElementById('save-deck-btn').disabled = (total < 30);
    }

    function toStartScreen() {
        document.getElementById('deck-builder-screen').style.display='none';
        document.getElementById('start-overlay').style.display='flex';
    }

    /* ------------------------------------------------------------------
       4. ê²Œì„ ë¡œì§
       ------------------------------------------------------------------ */
    function startGame(userFirst) {
        document.getElementById('start-overlay').style.display='none';
        isFirst = userFirst;
        
        pDeck = [];
        myDeckList.forEach(item => { for(let i=0; i<item.count; i++) pDeck.push(createInstance(item.data)); });
        shuffle(pDeck);

        eDeck = [];
        for(let i=0; i<40; i++) eDeck.push(createInstance(cardsDB[Math.floor(Math.random()*(cardsDB.length-1))]));

        for(let i=0; i<3; i++) { draw(pDeck, pHand); draw(eDeck, eHand); }

        if(isFirst) {
            pEP=2; eEP=3; draw(eDeck, eHand);
            startPlayerTurn();
        } else {
            pEP=3; eEP=2; draw(pDeck, pHand);
            startEnemyTurn();
        }
        updateView();
    }

    function createInstance(data) {
        return {
            ...data, uid: Math.random().toString(),
            curAtk: data.atk, curHp: data.hp,
            canAttack: false, hasAttacked: false, evolved: false, summonTurn: -1,
            passives: data.passives ? [...data.passives] : [] // [ìˆ˜ì •] ì•ˆì „í•œ ë³µì‚¬
        };
    }

    function startPlayerTurn() {
        isPlayerTurn = true; myTurnCount++;
        pMaxMana = Math.min(10, myTurnCount); pMana = pMaxMana;
        evolvedThisTurn = false; isEvolveMode = false;
        pField.forEach(c => { c.canAttack = true; c.hasAttacked = false; });
        draw(pDeck, pHand);
        log(`--- ${myTurnCount}í„´ ---`);
        document.getElementById('end-turn').disabled = false;
        updateView();
    }

    function endTurn() {
        if(!isPlayerTurn) return;
        isPlayerTurn = false; isEvolveMode = false;
        document.getElementById('end-turn').disabled = true;
        pField.forEach(c => c.canAttack = false);
        updateView();
        setTimeout(startEnemyTurn, 1000);
    }

    /* --- [ìˆ˜ì •] ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ (í•„ë“œ ì¸ì‹ ê°•í™”) --- */
    function setupDragEvents(el, source, index) {
        el.setAttribute('draggable', 'true');
        el.onmousedown = (e) => e.stopPropagation(); 
        
        el.addEventListener('dragstart', (e) => {
            if(!isPlayerTurn) { e.preventDefault(); return; }
            dragSource = source; draggedIdx = index;
            
            // [ì¤‘ìš”] ë°ì´í„° ì„¤ì •í•´ì•¼ íŒŒì´ì–´í­ìŠ¤ ë“±ì—ì„œ ì‘ë™
            e.dataTransfer.setData('text/plain', index);
            e.dataTransfer.effectAllowed = 'move';
            
            el.classList.add('dragging');
            if(source === 'field') highlightTargets(pField[index]);
        });
        
        el.addEventListener('dragend', () => {
            el.classList.remove('dragging');
            clearHighlights();
            dragSource = null; draggedIdx = -1;
        });
    }

    // [ì¤‘ìš”] í•„ë“œ ë“œë¡­ì¡´ ì„¤ì • (ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë°©ì‹)
    const pFieldEl = document.getElementById('player-field');
    pFieldEl.addEventListener('dragover', (e) => {
        e.preventDefault(); // í•„ìˆ˜
        if(dragSource === 'hand') pFieldEl.classList.add('drag-hover');
    });
    pFieldEl.addEventListener('dragleave', () => pFieldEl.classList.remove('drag-hover'));
    pFieldEl.addEventListener('drop', (e) => {
        e.preventDefault();
        pFieldEl.classList.remove('drag-hover');
        if(dragSource === 'hand') playCard(draggedIdx);
    });

    function setupAttackTarget(el, type, index) {
        el.addEventListener('dragover', (e) => e.preventDefault());
        el.addEventListener('drop', (e) => {
            e.preventDefault();
            if(dragSource === 'field') attack(draggedIdx, type, index);
        });
    }

    /* --- ê²Œì„ ì•¡ì…˜ --- */
    function playCard(idx) {
        const card = pHand[idx];
        let cost = card.cost; let enhanced = false;
        if(card.enhance && pMana >= card.enhance.cost) { cost = card.enhance.cost; enhanced = true; }

        if(pMana >= cost && pField.length < 5) {
            pMana -= cost; pHand.splice(idx, 1);
            card.summonTurn = myTurnCount;
            // íŒ¨ì‹œë¸Œ í™•ì¸ (ì•ˆì „í•˜ê²Œ ì²˜ë¦¬)
            const ps = card.passives || [];
            if(ps.includes('rush') || ps.includes('storm')) card.canAttack = true;
            
            pField.push(card);
            log(`${card.name} ì†Œí™˜`);
            if(card.fanfare) applyEffects(card.fanfare, card, null);
            if(enhanced && card.enhance.effects) applyEffects(card.enhance.effects, card, null);
            updateView();
        }
    }

    function attack(attackerIdx, targetType, targetIdx) {
        const att = pField[attackerIdx];
        if(!att.canAttack) return;
        
        const isSummonTurn = att.summonTurn === myTurnCount;
        const ps = att.passives || [];
        const hasStorm = ps.includes('storm');
        const warders = eField.filter(c => (c.passives||[]).includes('ward') && !(c.passives||[]).includes('ambush'));
        
        if(targetType === 'hero') {
            if(isSummonTurn && !hasStorm) { log("ëŒì§„ì€ ë¦¬ë” ê³µê²© ë¶ˆê°€"); return; }
            if(warders.length > 0) { log("ìˆ˜í˜¸ í•˜ìˆ˜ì¸ì´ ìˆìŠµë‹ˆë‹¤."); return; }
        }
        if(targetType === 'unit') {
            const target = eField[targetIdx];
            const tps = target.passives || [];
            if(tps.includes('ambush') || tps.includes('intimidate')) return;
            if(warders.length > 0 && !tps.includes('ward')) { log("ìˆ˜í˜¸ í•˜ìˆ˜ì¸ì„ ë¨¼ì € ê³µê²©í•˜ì„¸ìš”."); return; }
        }

        att.canAttack = false; att.hasAttacked = true;
        if(ps.includes('ambush')) removePassive(att, 'ambush');

        let targetCard = targetType==='unit' ? eField[targetIdx] : null;
        if(att.strike) applyEffects(att.strike, att, targetCard);
        
        if(targetType === 'unit') {
            const def = eField[targetIdx];
            if(att.clash) applyEffects(att.clash, att, def);
            if(def.clash) applyEffects(def.clash, def, att);
            
            if(att.curHp > 0 && def.curHp > 0) {
                const dmgToDef = calcDmg(att.curAtk, def);
                const dmgToAtt = calcDmg(def.curAtk, att);
                dealDamage(def, dmgToDef); dealDamage(att, dmgToAtt);
                
                if((att.passives||[]).includes('drain')) pHP += dmgToDef;
                if((def.passives||[]).includes('drain')) eHP += dmgToAtt;
                if((att.passives||[]).includes('bane')) def.curHp = 0;
                if((def.passives||[]).includes('bane')) att.curHp = 0;
            }
        } else {
            eHP -= att.curAtk;
            if((att.passives||[]).includes('drain')) pHP += att.curAtk;
        }
        resolveDeaths(); updateView();
    }

    function toggleEvolve() {
        if(!isPlayerTurn) return;
        const unlock = isFirst ? 5 : 4;
        if(myTurnCount < unlock || pEP <= 0 || evolvedThisTurn) return;
        isEvolveMode = !isEvolveMode;
        updateView();
    }

    function doEvolve(idx) {
        const c = pField[idx]; if(c.evolved) return;
        pEP--; evolvedThisTurn = true; isEvolveMode = false;
        c.evolved = true; c.curAtk += 2; c.curHp += 2;
        if(!c.hasAttacked) c.canAttack = true;
        log(`${c.name} ì§„í™”!`);
        if(c.evolve) applyEffects(c.evolve, c, null);
        updateView();
    }

    /* --- ìœ í‹¸ --- */
    function calcDmg(dmg, target) {
        if((target.passives||[]).includes('barrier')) { removePassive(target, 'barrier'); return 0; }
        return dmg;
    }
    function dealDamage(u, v) { u.curHp -= v; }
    function removePassive(u, p) { u.passives = (u.passives||[]).filter(x=>x!==p); }
    
    function resolveDeaths() {
        const proc = (list) => {
            for(let i=list.length-1; i>=0; i--) {
                if(list[i].curHp <= 0) {
                    const c = list[i]; list.splice(i, 1);
                    if(c.lastWords) applyEffects(c.lastWords, c, null);
                }
            }
        }
        proc(pField); proc(eField);
        if(pHP<=0 || eHP<=0) { alert(pHP<=0 ? "íŒ¨ë°°..." : "ìŠ¹ë¦¬!"); location.reload(); }
    }

    function applyEffects(effs, src, tgt) {
        if(!effs) return;
        effs.forEach(ef => {
            if(ef.type==='draw') for(let i=0;i<ef.val;i++) draw(pDeck, pHand);
            if(ef.type==='buff') { src.curAtk+=ef.atk; src.curHp+=ef.hp; }
            if(ef.type==='buff_all') pField.forEach(c=>{c.curAtk+=ef.atk; c.curHp+=ef.hp;});
            if(ef.type==='heal_leader') pHP+=ef.val;
            if(ef.type==='damage_leader') { if(ef.target==='enemy') eHP-=ef.val; else pHP-=ef.val; }
            if(ef.type==='aoe_damage') eField.forEach(c=>c.curHp-=ef.val);
            if(ef.type==='destroy_enemy') if(eField.length>0) eField.pop();
            if(ef.type==='destroy_all_others') { pField=[src]; eField=[]; }
            if(ef.type==='return_to_hand') if(pHand.length<9) pHand.push(createInstance(cardsDB.find(x=>x.name===src.name)));
            if(ef.type==='summon') { 
                const token = cardsDB.find(x=>x.id===ef.id);
                if(pField.length<5) pField.push(createInstance(token));
            }
        });
        resolveDeaths();
    }

    function draw(deck, hand) { if(deck.length>0 && hand.length<9) hand.push(deck.pop()); }
    function shuffle(a) { a.sort(()=>Math.random()-0.5); }
    function log(m) { const d=document.createElement('div'); d.innerText=m; document.getElementById('log-window').prepend(d); }

    /* --- AI --- */
    function startEnemyTurn() {
        let eTurn = myTurnCount + (isFirst ? 0 : 1);
        eMaxMana = Math.min(10, isFirst ? myTurnCount : myTurnCount+1); eMana = eMaxMana;
        eField.forEach(c => c.canAttack = true); draw(eDeck, eHand);
        
        eHand.sort((a,b)=>b.cost-a.cost);
        for(let i=eHand.length-1; i>=0; i--) {
            let c=eHand[i], cost=c.cost;
            if(c.enhance && eMana >= c.enhance.cost) cost = c.enhance.cost;
            if(eMana >= cost && eField.length < 5) {
                eMana -= cost; eHand.splice(i,1); c.summonTurn=999;
                const ps = c.passives || [];
                if(ps.includes('rush') || ps.includes('storm')) c.canAttack=true;
                eField.push(c); log(`ğŸ”´ ì  ${c.name} ì†Œí™˜`);
                if(cost>c.cost && c.enhance) applyEffects(c.enhance.effects, c, null);
                else if(c.fanfare) applyEffects(c.fanfare, c, null);
            }
        }
        
        const unlock = isFirst ? 4 : 5;
        if(eTurn >= unlock && eEP > 0 && eField.length > 0) {
            const t = eField.find(c => !c.evolved);
            if(t) { eEP--; t.evolved=true; t.curAtk+=2; t.curHp+=2; t.canAttack=true; log("âš¡ ì  ì§„í™”"); }
        }
        updateView();

        setTimeout(() => {
            const pWard = pField.some(c=>(c.passives||[]).includes('ward') && !(c.passives||[]).includes('ambush'));
            eField.forEach(att => {
                if(!att.canAttack) return;
                const attPs = att.passives || [];
                let target = null;
                if(!pWard && att.curAtk >= pHP) { pHP -= att.curAtk; log("ì  ë¦¬ë” ê³µê²©!"); return; }
                if(pWard) target = pField.find(c=>(c.passives||[]).includes('ward'));
                else if(pField.length > 0) target = pField[0];

                if(target) {
                    att.curHp -= target.curAtk; target.curHp -= att.curAtk;
                    log(`âš”ï¸ ì  ${att.name} -> ${target.name}`);
                } else if (!pWard && !attPs.includes('rush')) {
                    pHP -= att.curAtk; log("ì  ë¦¬ë” ê³µê²©");
                }
            });
            resolveDeaths(); updateView(); startPlayerTurn();
        }, 1500);
    }

    /* --- ë·° ë Œë”ë§ --- */
    function updateView() {
        document.getElementById('mana').innerText = `${pMana}/${pMaxMana}`;
        document.getElementById('p-hp').innerText = pHP; document.getElementById('e-hp').innerText = eHP;
        renderOrbs('p-ep', pEP, isFirst?2:3); renderOrbs('e-ep', eEP, isFirst?3:2);
        
        const evBtn = document.getElementById('evolve');
        evBtn.classList.toggle('active', isEvolveMode);
        
        renderHand(pHand, 'player-hand', true); renderHand(eHand, 'enemy-hand', false);
        renderField(pField, 'player-field', true); renderField(eField, 'enemy-field', false);
        setupAttackTarget(document.getElementById('enemy-hero'), 'hero', 0);
    }

    function renderOrbs(id, count, max) {
        const el = document.getElementById(id); el.innerHTML='';
        for(let i=0; i<max; i++) {
            const o = document.createElement('div'); o.className = `orb ${i<count?'on':''}`; el.appendChild(o);
        }
    }

    function renderCardInner(c, hide) {
        if(hide) return `<div class="card enemy-card-back"><div style="width:100%;height:100%;background:linear-gradient(135deg,#222,#444);"></div></div>`;
        
        const passives = c.passives || [];
        let badges = '';
        if(passives.includes('ward')) badges+='<span class="keyword-icon">ğŸ›¡ï¸</span>';
        if(passives.includes('bane')) badges+='<span class="keyword-icon" style="background:#8e44ad">â˜ ï¸</span>';
        if(passives.includes('storm')) badges+='<span class="keyword-icon" style="background:#2980b9">âš¡</span>';
        if(passives.includes('rush')) badges+='<span class="keyword-icon" style="background:#f39c12">ğŸ‘Ÿ</span>';
        if(passives.includes('ambush')) badges+='<span class="keyword-icon" style="background:#555">ğŸ¥·</span>';
        if(passives.includes('drain')) badges+='<span class="keyword-icon" style="background:#c0392b">ğŸ©¸</span>';
        if(passives.includes('barrier')) badges+='<span class="keyword-icon" style="background:#f1c40f">ğŸ”°</span>';

        let activeEnhance = !hide && isPlayerTurn && c.enhance && pMana >= c.enhance.cost && !c.summonTurn;
        let displayCost = activeEnhance ? c.enhance.cost : c.cost;
        
        return `
            <div class="card-cost ${activeEnhance?'enhance-cost':''}">${displayCost}</div>
            <div class="icon-row">${badges}</div>
            <div class="card-top"><div class="card-art" style="background-image:url('${c.art}')"></div></div>
            <div class="card-bottom">
                <div class="card-name">${c.name}</div>
                <div class="card-desc">${c.desc||''}</div>
                <div class="stat-box stat-atk">${c.curAtk!==undefined?c.curAtk:c.atk}</div>
                <div class="stat-box stat-hp">${c.curHp!==undefined?c.curHp:c.hp}</div>
            </div>
        `;
    }

    function renderHand(list, id, isP) {
        const el = document.getElementById(id); el.innerHTML='';
        list.forEach((c, i) => {
            const d = document.createElement('div');
            const p = c.passives || [];
            d.className = `card ${isP?'in-hand':''} ${p.join(' ')}`;
            d.innerHTML = renderCardInner(c, !isP);
            if(isP) {
                let cost = c.enhance && pMana >= c.enhance.cost ? c.enhance.cost : c.cost;
                if(pMana >= cost && isPlayerTurn) d.classList.add('playable');
                setupDragEvents(d, 'hand', i);
            }
            el.appendChild(d);
        });
    }

    function renderField(list, id, isP) {
        const el = document.getElementById(id); el.innerHTML='';
        list.forEach((c, i) => {
            const d = document.createElement('div');
            const p = c.passives || [];
            d.className = `card ${p.join(' ')} ${c.evolved?'evolved':''}`;
            d.innerHTML = renderCardInner(c, false);
            if(isP) {
                if(isEvolveMode && !c.evolved) { d.style.boxShadow="0 0 15px white"; d.onclick=()=>doEvolve(i); }
                else if(c.canAttack && isPlayerTurn && !isEvolveMode) { d.classList.add('can-attack'); setupDragEvents(d, 'field', i); }
                else d.classList.add('exhausted');
            } else {
                setupAttackTarget(d, 'unit', i);
            }
            el.appendChild(d);
        });
    }

    function highlightTargets(card) {
        const isSummon = card.summonTurn === myTurnCount;
        const storm = (card.passives||[]).includes('storm');
        const warders = eField.filter(c=>(c.passives||[]).includes('ward') && !(c.passives||[]).includes('ambush'));
        
        if(warders.length > 0) {
            const nodes = document.getElementById('enemy-field').children;
            eField.forEach((c, i) => {
                if((c.passives||[]).includes('ward') && !(c.passives||[]).includes('ambush')) 
                    nodes[i].classList.add('valid-target');
            });
        } else {
            if(!isSummon || storm) document.getElementById('enemy-hero').classList.add('valid-target');
            const nodes = document.getElementById('enemy-field').children;
            eField.forEach((c, i) => {
                if(!(c.passives||[]).includes('ambush') && !(c.passives||[]).includes('intimidate')) nodes[i].classList.add('valid-target');
            });
        }
    }
    function clearHighlights() { document.querySelectorAll('.valid-target').forEach(e=>e.classList.remove('valid-target')); }

    initBuilder();
</script>
</body>
</html>